
1. Method conventions:

INPUT abs
OUTPUT abs

Means: Abs *must* exist before (already enforced).


INPUT 
OUTPUT abs

Means: Abs may or may not exist before. It is the responsibility of
the programmer to specify (and document!) how the method deals with
previous content of abs. This must be explained in the online
documentation for the method.


2. Convention for Generic methods: The same argument may occur both as
an input and an output argument. Example

VectorAdd(p_abs,p_abs)

will flip the order of the elements of p_abs.


3. There will be a few `generic' WSVs of each group. Convention:

index1, index2, matrix1, matrix2, etc..

4. Setting up method lists:

   MethodListDefine (already implemented)
   ArrayOfMethodListDefine (needed for example for the absorption
   			    methods, where we want to be able to
                            specify the lineshape 
   			    separately for each tg).

5. Outline of new absorption structure:

WSVs: tgs, lines, lines_per_tg
Methods: Stays as it is:

WSV: lineshape was in the past a complicated variable containing identification
     of the lineshape to use. In future:

     ArrayOfMethodList ls_methods: The lineshape methods to use for
                                          each tg.

WSVs for lineshapes: 
     Vector ls: The output
     Numeric ls_f0:       Center frequency
     Vector f_mono:    frequency grid 
     Numeric ls_gamma:    Pressure broadening parameter
     Numeric ls_sigma:    Dopler broadening parameter

Methods: Each lineshape function will be a method:

Name				 Output	       Input

lsDoppler		 ls     ls_f0, f_mono, ls_gamma
lsLorentz		 ls     ls_f0, f_mono, ls_gamma
lsVoigtKuntz3		 ls     ls_f0, f_mono, ls_gamma, ls_sigma
lsVoigtKuntz4		 ls     ls_f0, f_mono, ls_gamma, ls_sigma
lsVoigtKuntz6		 ls     ls_f0, f_mono, ls_gamma, ls_sigma
lsVoigtDrayson		 ls     ls_f0, f_mono, ls_gamma, ls_sigma
lsRosenkranzVoigtDrayson ls     ls_f0, f_mono, ls_gamma, ls_sigma
lsRosenkranzVoigtKuntz6	 ls     ls_f0, f_mono, ls_gamma, ls_sigma
                       

Furthermore, there are methods for the normalization:

lsNormQuadratic           ls	ls, ls_f0, f_mono

This one multiplies the lineshape with a (f/f0)^2 term. In this case,
ls is both input and output, as it must exist before.

Note the naming convention: Variables that are only interesting as
input parameters to the ls functions are called ls_xxx.

For ease of use, lets have specific methods to set up the method
lists:

# For all tgs the same lineshapes:
ls_methodsDefine{["lsVoigtDrayson","lsNormQuadratic"]}

# Or individually:
tgsDefine{["O3","H2O","ClO"]}
ls_methodsDefinePerTg{
  name = "O3"
  methods = ["lsVoigtDrayson","lsNormQuadratic"]
}
ls_methodsDefinePerTg{
  name = "ClO"
  methods = ["lsVoigtDrayson","lsNormQuadratic"]
}

Note that we did not define the methods for the tg H2O, which is ok as
long as we use one of the complete absorption models for this tg.

There will be a file method_lists.cc, which holds definitions of
method lists. These are necessary to automatically create functions
for safe communication of the calling method with the method
list. Entries in the file will look like this

ml_data.push_back(
  MlRecord(
    NAME("ls_methods"),
    DESCRIPTION("Computes the line shape function."),
    OUTPUT(ls_),
    INPUT(ls_f0_,f_mono_,ls_gamma_,ls_sigma_)))

The automatically generated interface function will then look like
this: 

execute_ls_methods(Vector& ls,
		          const MethodList ls_methods,
                          const Numeric& ls_f0,
                          const Vector& f_mono,
                          const Numeric& ls_gamma,
                          const Numeric& ls_sigma,
                          bool quickandsilent=false);

Maybe you find it confusing that ls_methods shows up both in
the name and in the argument list. However, this is necessary to
ensure that the calling function possesses ls_methods (has it
in its INPUT list).

Note, that the call will be carried out via the workspace. So, the
methods in the lisgt may take additional arguments that the calling
function is now aware of. In that case this WSV must be occupied,
i.e., must have been defined before.

The last argument can be used to suppress consistency checking and
output if a method list shall be executed many times, as for example
the lineshape. In that case, only one first call should be made with
quickandsilent==false, the rest with quickandsilent==true.


WSV: xsec_per_tg will hold the true absorption cross sections for each
tag group (absorption coefficient divided by partial number density
[m^-2]). This is different from the current xsec_per_tg, which
contains absorption coefficient divided by VMR. True cross sections
are more general, since they also work for liquid and ice particles. 

WSV: xsec will hold the absorption cross section for one tg. This
variable can be used to accumulate the absorption for one tg by
applying different methods in sequence. 

Methods:

xsecAddLines (line spectrum)
xsecAddH2O-MPM93 (complete Liebe model)
xsecAddH2O-SelfConstStandardType (the simple empirical continuum
                                  parameterization for the self
                                  continuum with adjustable
				  parameters)  

WSV Groups: TagGroup (one tag group)
            ArrayOfTagGroup (what is now TagGroups)

WSV: TagGroup xsec_tg: The current tag group for absorption
                       calculation.
     Vector   xsec_vmr: The current vmr profile (in the case of liquid
                        or solid particles the mass density)

In general, a sequence of xsec methods can be given in an xsec_methods
list. It has the definition:

ml_data.push_back(
  MlRecord(
    NAME("xsec_methods"),
    DESCRIPTION("Computes absorption cross sections for one species.\n"
                "The species is identified by its tg."),
    OUTPUT(xsec_),
    INPUT(xsec_tg_,xsec_vmr_)))



6. RT and Gridding
==================

There will be Tensor3-Tensor5, extending the concept of Matrix. The
last index is always the one that is continuous in memory. The second
to last index has a step width equal to the numer of elements of the
last index, and so on.

Functions:

Tensor3 a
cout << a(1,2,3);      // Element access
cout << a.npage();     // Number of pages.

Tensor dimensions are:

(library), (cupboard), shelf, book, page, row, column


Dimemensions of some important variables:

Position: lon, lat, p/z, as needed.

Atmospheric fields (like t_abs): Tensor3(lon,lat,p/z)

Grids: lon_grid, lat_grid, p_grid (or z_grid)

Radiation field: (lon,lat,p/z,theta,phi)
(1-d case:       (1,  1,  p/z,theta,1  ) )
(that's a one there!)

To define a line of sight: Vector(5)(lon,lat,p/z,theta,phi)

Interpolation routine:

interp_1d(Numeric& result, Numeric position, Vector field, Vector grid)
interp_2d(Numeric& result, Numeric position1, Numeric position2,
          Matrix field, Vector grid1, Vector grid2)

Absorption lookup table:

struct abs_table {
ArrayOfTagGroup tgs;      // Species
Matrix          vmrs;     // [tgs.nelem(), p.nelem()]
Vector          p;        // Pressure
Vector          T;	  // Same length as p
Vector          delta_T;  // Temperature offsets from T
Vector          f;        // Frequency

Tensor table;             // [tgs.nelem(),
                              delta_T.nelem(),
                              p.nelem(),
                              f.nelem()]
}

How to extract absorption:

Lookup functions returning 

Matrix abs(number,f)

Vector abs (for all frequencies), given

a) total abs, given Index in p and T plus ArrayOfIndex in tgs and vmrs
   to match to select species that should be summed.

b) total abs, given Index in p and Numeric value for T plus
   ArrayOfIndex to select tgs that should be summed. This will do an
   interpolation in T.

c) total abs, given Numeric value in p and Numeric value for T plus
   ArrayOfIndex to select tgs that should be summed. This will do an
   interpolation in p and T.



7. Schedule
============

ARTS-1-0-0: This month. At the same time make 1-0 a side branch and
start with 2-0-0 on the main trunk.

Tensors: This month?
Method lists: March 2002.