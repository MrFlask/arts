#DEFINITIONS:  -*-sh-*-
# Simple simulations of ground-based measurements of ozone at 110.8 GHz,
# mainly to test different sensor response methods.
# User defined variables are also used heavily, to set up consistent 
# frequency grids inside the control file (instead of loading files).
# This includes the generation of a compact, non-uniform, f_grid.
#
# Author: Patrick Eriksson


Arts2 {

INCLUDE "general.arts"


# ---- f_grid ----------------------------------------------------------------

NumericCreate( v0 )
NumericCreate( fw )
IndexCreate( nlogpart )
NumericCreate( fw_fine )
NumericCreate( df_fine )

# Centre frequency
NumericSet( v0, 1.108360400e+11 )

# One sided width of f_grid
NumericSet( fw, 330e6 )

# Numer of points (on each side) of logarithmic part
IndexSet( nlogpart, 35 )

# One sided width of fine grid at centre of f_grid
NumericSet( fw_fine, 240e3 )

# Spacing of this fine grid
NumericSet( df_fine, 40e3 )

# A logarithmically spaced grid between [fw_fine,fw]
NumericCreate( f1 )
NumericCreate( f2 )
VectorCreate( flog )
Copy( f1, fw_fine )
Copy( f2, fw )
VectorNLogSpace( flog, nlogpart, f1, f2 )

# First part of f_grid is flog "mirrored"
VectorFlip( f_grid, flog )
VectorScale( f_grid, f_grid, -1 )

# Append an equidistant grid between [-fw_fine+df_fine,fw_fine-df_fine]
VectorCreate( feqd )
Copy( f1, fw_fine )
NumericScale( f1, f1, -1 )
NumericAdd( f1, f1, df_fine )
NumericScale( f2, f1, -1 )
VectorLinSpace( feqd, f1, f2, df_fine )
Append( f_grid, feqd )

# Append flog
Append( f_grid, flog )

# Add v0
VectorAddScalar( f_grid, f_grid, v0 )


# ---- Species ---------------------------------------------------------------

SpeciesSet( abs_species, [ "O3", "H2O" ] )


# ---- Atmospheric scenario --------------------------------------------------

# A pressure grid rougly matching 0 to 80 km in 1 km steps.
VectorNLogSpace( p_grid, 81, 1.013e5, 1 )

AtmRawRead( t_field_raw, z_field_raw, vmr_field_raw, abs_species, 
                                  "../atmosphere_data/tropical" )
VectorSet( lat_grid, [ 10 ] )
AtmFieldsCalc


# ---- Absorption ------------------------------------------------------------

ReadXML( abs_lines, "ozone_line.xml" )
abs_lines_per_speciesCreateFromLines

abs_cont_descriptionInit

AbsInputFromAtmFields
SpeciesSet( abs_nls, [] )
VectorSet( abs_nls_pert, [] )
VectorSet( abs_t_pert, [] )
abs_lookupCreate

AgendaSet( abs_scalar_gas_agenda ){
  abs_scalar_gasExtractFromLookup
}


# ---- Observation geometry --------------------------------------------------

NumericCreate( z_platform )
NumericCreate( za )
 
# Platform altitude
NumericSet( z_platform, 50 )

# Zenith angle
NumericSet( za, 60 )

MatrixSetConstant( sensor_pos, 1, 1, z_platform )
Copy( z_surface, sensor_pos )
sensor_posAddRgeoid
MatrixSetConstant( sensor_los, 1, 1, za )


# ---- Finalise atmosphere ---------------------------------------------------

basics_checkedCalc
cloudbox_checkedCalc

# Important to run HSE before yCalc if temperature jacobians with HSE 
# will be used 
Extract( p_hse, p_grid, 0 )
NumericSet( z_hse_accuracy, 0.1 )
z_fieldFromHSE





# ---- Turn off cosmic background radiation  ---------------------------------

# This to faciliate comparison of spectra from the different observation modes

AgendaSet( iy_space_agenda ){
  Ignore( rte_pos )
  Ignore( rte_los )
  nelemGet( nelem, f_grid )
  MatrixSetConstant( iy, nelem, stokes_dim, 0 )
}



# --- Common sensor settings -------------------------------------------------

FlagOn( sensor_norm )

StringSet( y_unit, "RJBT" )

NumericCreate( f_resolution )
NumericCreate( f_switch )

# Resolution (and also channel spacing) of spectrometer
NumericSet( f_resolution, 500e3 )

# Size of frequency throw
NumericSet( f_switch, 10e6 )

backend_channel_responseGaussian( backend_channel_response, f_resolution, 2 )

# Calculate where first channel can start (considering f_switch and 
# channel widths)
Copy( f1, fw )
NumericScale( f1, f1, -1 )
NumericAdd( f1, f1, f_switch )
NumericAdd( f1, f1, f_resolution )
Copy( f2, f1 )
NumericScale( f2, f2, -1 )

VectorLinSpace( f_backend, f1, f2, f_resolution )
VectorAddScalar( f_backend, f_backend, v0 )



# --- Spectrum for "direct" observation (load switching) ---------------------

AntennaOff
sensor_responseInit
sensor_responseBackend


# --- Define jacobian -------------------------------------------------------
#
# Jacobians are tested/demonstrated mainly elsewhere, but some jacobians 
# are better tested here 
#
jacobianInit
jacobianAddFreqShiftAndStretch( jacobian_quantities, jacobian_agenda, 
                                f_grid, "interp", 50e3, 1 )
StringCreate( calcmethod )
StringSet( calcmethod, "analytical" )
#StringSet( calcmethod, "perturbation" )
jacobianAddTemperature( jacobian_quantities, jacobian_agenda,
    atmosphere_dim, p_grid, lat_grid, lon_grid, p_grid, lat_grid, lon_grid, 
    "on", calcmethod, 1 )
jacobianClose


yCalc
#
WriteXML( output_file_format, y, "TestGbased.y1.xml" )
WriteXML( output_file_format, y_f, "TestGbased.f.xml" )
WriteXML( output_file_format, jacobian, "TestGbased.J1.xml" )



# --- Beam switching ---------------------------------------------------------

NumericCreate( za_negative )
Copy( za_negative, za )
NumericScale( za_negative, za_negative, -1 )

VectorNLinSpace( mblock_za_grid, 2, za_negative, 0 )
sensor_responseInit
sensor_responseBeamSwitching
sensor_responseBackend

yCalc
#
WriteXML( output_file_format, y, "TestGbased.y2.xml" )



# --- Frequency switching -----------------------------------------------------

Copy( f1, f_switch )
NumericScale( f1, f1, -1 )

AntennaOff
sensor_responseInit
sensor_responseBackendFrequencySwitching( sensor_response, sensor_response_f,
     sensor_response_pol, sensor_response_za, sensor_response_aa, 
     sensor_response_f_grid, sensor_response_pol_grid, sensor_response_za_grid,
     sensor_response_aa_grid, f_backend, backend_channel_response, sensor_norm,
     f1, f_switch )

yCalc
#
WriteXML( output_file_format, y, "TestGbased.y3.xml" )

}
